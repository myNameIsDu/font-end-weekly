## Vercel 支持 pnpm
如果项目中存在 pnpm-lock.yaml，使用 pnpm install

https://vercel.com/changelog/projects-using-pnpm-can-now-be-deployed-with-zero-configuration

## Remixing React Router

remix 中的数据和异步ui管理将应用于react-router，解决常见的瀑布流问题
```
import * as React from "react";
import {
  BrowserRouter,
  Routes,
  Route,
  useLoaderData,
  Form,
} from "react-router-dom";

ReactDOM.render(
  <BrowserRouter>
    <Routes
      // if you're not server rendering, this manages the
      // initial loading state
      fallbackElement={<BigSpinner />}
      // any rendering or async loading and mutation errors will
      // automatically be caught and render here, no more error
      // state tracking or render branching
      exceptionElement={<GlobalErrorPage />}
    >
      <Route
        // Loaders provide data to route component and are initiated
        // when the URL changes
        loader={({ signal }) => {
          // React Router speaks the Web Fetch API, so you can return
          // a web fetch Response and it'll automatically be
          // deserialized with `res.json()`. No more useFetch hooks
          // and messing with their pending states in every component
          // that needs them.
          return fetch("/api/user.json", {
            // It also handles navigation interruptions and (as long as
            // you pass the signal) cancels the actual fetch.
            signal,
          });
        }}
      >
        <Route
          path="projects"
          element={<Projects />}
          // exceptions bubble, so you can handle them in context or
          // just let them bubble to the top, tons of happy paths!
          exceptionElement={<TasksErrorPage />}
          loader={async ({ signal }) => {
            // You can also unwrap the fetch yourself and write
            // simple `async/await` code (try that inside a useEffect 🥺).
            // You don't even have to `fetch`, you can get data from
            // anywhere (localStorage, indexedDB whatever)
            let res = await fetch("/api/tasks.json", { signal });

            // if at any point you can't render the route component
            // based on the data you're trying to load, just `throw` an
            // exception and the exceptionElement will render instead.
            // This keeps your happy path happy, and your exception path,
            // uh, exceptional!
            if (res.status === 404) {
              throw { notFound: true };
            }

            return res.json();
          }}
        >
          <Route
            path=":projectId"
            element={<Projects />}
            // a lot of your loading is gonna be this simple, React
            // Router will handle all the pending states and expose it
            // to you so you can build pending/optimistic UI
            loader={async ({ signal, params }) =>
              fetch(`/api/projects/${params.projectId}`, { signal })
            }
          />
        </Route>
        <Route index element={<Index />} />
      </Route>
    </Routes>
  </BrowserRouter>
);
```

https://remix.run/blog/remixing-react-router#component-fetching-and-render-fetch-chains

## rendering on web

![SN7lOq](https://raw.githubusercontent.com/myNameIsDu/images/main/uPic/SN7lOq.png)

https://developers.google.com/web/updates/2019/02/rendering-on-the-web#rehydration

## Parcel v2.4.0
默认使用 Parcel css 作为 css 转换和压缩工具

https://parceljs.org/blog/v2-4-0/

## CodeSandbox 支持点组件跳转到源码
https://twitter.com/compuives/status/1506307886514769921

## LowCodeEngine
阿里出的低代码引擎

https://github.com/alibaba/lowcode-engine/blob/main/packages/engine/README-zh_CN.md

## Motion Developer Tools
一个调试动画的chrome extension，但是只能 Sponsor 使用

https://chrome.google.com/webstore/detail/motion-developer-tools/mnbliiaiiflhmnndmoidhddombbmgcdk

## Chrome Extension CLI

chrome extension 的脚手架

https://github.com/dutiyesh/chrome-extension-cli